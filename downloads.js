// downloads.js
// => fichier JS qui définit window.DOWNLOADS
// IMPORTANT : sauvegarde en UTF-8 **sans BOM** et inclus avec <script src="downloads.js"></script>

window.DOWNLOADS = [
{
  "filename": "code/Architecture_finder.zip",
  "title": "Architecture Finder",
  "category": "algorithme",
  "version": "code",
  "size_bytes": 15612,
  "description": "Trouve une chaine RF optimale.",
  "code_py": "#!\/usr\/bin\/env python3\r\n# -*- coding: utf-8 -*-\r\n\"\"\"\r\nScript : architecture_optimizer.py\r\nBut    : g\u00E9n\u00E9rer et scorer des architectures RF (placement LNAs + configurations d\'att\u00E9nuateurs)\r\nAuteur : (ton nom)\r\nUsage  : placer le YAML d\'entr\u00E9e (components.yaml) dans le m\u00EAme dossier et lancer le script.\r\nSortie : results.txt (liste des architectures test\u00E9es) + r\u00E9sum\u00E9 console (meilleure architecture)\r\n\r\nConventions et unit\u00E9s :\r\n - Tous les niveaux en dB (gain_dB, insertion_loss_dB, nf_dB)\r\n - OP1dB dans le YAML donn\u00E9 en dBm (op1db_dBm ou p1db_dBm accepted)\r\n - Fonctions utilitaires convertissent dB <-> lin\u00E9aire :\r\n     lin = 10^(dB\/10)\r\n - Pour les composants passifs (type \'filter\' ou \'switch\'), on attend\r\n   insertion_loss_dB (positive) et on consid\u00E8re :\r\n     gain_dB = -insertion_loss_dB\r\n     nf_dB   = insertion_loss_dB  (hypoth\u00E8se : NF = pertes d\'insertion)\r\n - Si un champ manque, valeurs par d\u00E9faut raisonnables sont appliqu\u00E9es\r\n   (ex : p1db par d\u00E9faut = +1000 dBm -> non contraignant).\r\n\"\"\"\r\n\r\nimport yaml\r\nimport itertools\r\nimport math\r\nimport os\r\n\r\n# -------------------------\r\n# Utils de base (conversions)\r\n# -------------------------\r\ndef non_empty_subsets(lst):\r\n    \"\"\"\r\n    Retourne toutes les sous-ensembles non vides de la liste `lst`.\r\n    Utilis\u00E9 pour tester toutes les combinaisons possibles de LNAs mobiles.\r\n    \"\"\"\r\n    return [list(subset) for r in range(1, len(lst)+1) for subset in itertools.combinations(lst, r)]\r\n\r\ndef db_to_lin(db):\r\n    \"\"\"Convertit dB -> lin\u00E9aire (puissance facteur).\"\"\"\r\n    return 10 ** (db \/ 10)\r\n\r\ndef lin_to_db(lin):\r\n    \"\"\"Convertit lin\u00E9aire -> dB. ATTENTION: lin doit \u00EAtre > 0.\"\"\"\r\n    return 10 * math.log10(lin)\r\n\r\n# -------------------------\r\n# Chargement YAML\r\n# -------------------------\r\ndef load_config(yaml_filename):\r\n    \"\"\"\r\n    Charge un fichier YAML situ\u00E9 dans le m\u00EAme dossier que ce script.\r\n    Retourne le contenu Python (dictionnaires \/ listes).\r\n    \"\"\"\r\n    script_dir = os.path.dirname(os.path.abspath(__file__))\r\n    yaml_path = os.path.join(script_dir, yaml_filename)\r\n    with open(yaml_path, \'r\') as f:\r\n        return yaml.safe_load(f)\r\n\r\n# -------------------------\r\n# Calculs physiques\r\n# -------------------------\r\ndef calc_nf(chain):\r\n    \"\"\"\r\n    Calcule le NF total de la cha\u00EEne via la formule de Friis (en lin\u00E9aire),\r\n    puis convertit en dB pour retour.\r\n    chain: liste d\'\u00E9tages avec \'gain_lin\' et \'nf_lin\' (valeurs lin\u00E9aires).\r\n    NF_total_lin = NF1 + (NF2-1)\/G1 + (NF3-1)\/(G1*G2) + ...\r\n    Retour: NF total en dB.\r\n    \"\"\"\r\n    nf_total_lin = chain[0][\'nf_lin\']\r\n    gain_prod = chain[0][\'gain_lin\']\r\n    for stage in chain[1:]:\r\n        nf_total_lin += (stage[\'nf_lin\'] - 1) \/ gain_prod\r\n        gain_prod *= stage[\'gain_lin\']\r\n    return lin_to_db(nf_total_lin)\r\n\r\ndef calc_p1db(chain):\r\n    \"\"\"\r\n    Calcule l\'OP1dB total en sortie d\'une cha\u00EEne.\r\n    M\u00E9thode utilis\u00E9e (identique au second script de r\u00E9f\u00E9rence) :\r\n      - pour chaque \u00E9tage i, on calcule le gain restant apr\u00E8s l\'\u00E9tage: gain_after[i]\r\n        (produit des gains des \u00E9tages qui suivent)\r\n      - on somme les inverses pond\u00E9r\u00E9es : inv_sum = sum( 1 \/ (p1db_lin_i * gain_after[i]) )\r\n      - P1dB_total_lin = 1 \/ inv_sum\r\n      - on retourne P1dB en dB (dBm, car p1db_lin provient d\'une conversion depuis dBm)\r\n    Remarques :\r\n      - Si un \u00E9tage n\'a pas de p1db d\u00E9fini ou valeur non positive, on l\'ignore (contrib. nulle).\r\n      - Si inv_sum == 0 (cas pathologique), on retourne -inf pour signaler l\'impossibilit\u00E9.\r\n    \"\"\"\r\n    if not chain:\r\n        return float(\'-inf\')\r\n\r\n    N = len(chain)\r\n    gain_after = [1.0] * N\r\n    prod = 1.0\r\n    # calcule produit des gains apr\u00E8s chaque \u00E9tage (on parcourt \u00E0 l\'envers)\r\n    for idx in range(N-1, -1, -1):\r\n        gain_after[idx] = prod\r\n        prod *= chain[idx][\'gain_lin\']\r\n\r\n    inv_sum = 0.0\r\n    for i, stage in enumerate(chain):\r\n        p1_lin = stage.get(\'p1db_lin\', None)\r\n        if not p1_lin or p1_lin <= 0:\r\n            # pas de P1dB renseign\u00E9 => on l\'ignore (comportement non contraignant)\r\n            continue\r\n        inv_sum += 1.0 \/ (p1_lin * gain_after[i])\r\n\r\n    if inv_sum <= 0:\r\n        return float(\'-inf\')\r\n\r\n    p1_total_lin = 1.0 \/ inv_sum\r\n    return lin_to_db(p1_total_lin)\r\n\r\n# -------------------------\r\n# Gestion des blocs verrouill\u00E9s\r\n# -------------------------\r\ndef group_locked_stages(stages):\r\n    \"\"\"\r\n    Construit des \'blocs\' \u00E0 partir d\'une liste de composants fixes en respectant\r\n    le champ `locked_with_next`: si un composant a locked_with_next=True,\r\n    on le regroupe avec le suivant dans le m\u00EAme bloc.\r\n    Retour: liste de blocs (chacun une liste de composants).\r\n    \"\"\"\r\n    blocks = []\r\n    current_block = []\r\n    for comp in stages:\r\n        current_block.append(comp)\r\n        if not comp.get(\'locked_with_next\', False):\r\n            blocks.append(current_block)\r\n            current_block = []\r\n    if current_block:\r\n        blocks.append(current_block)\r\n    return blocks\r\n\r\ndef flatten_block_names(block):\r\n    \"\"\"Retourne un nom simple pour le bloc : concat\u00E9nation des noms s\u00E9par\u00E9s par \' + \'.\"\"\"\r\n    return \" + \".join(comp[\'name\'] for comp in block)\r\n\r\ndef flatten_block_stages(block):\r\n    \"\"\"\r\n    Transforme un bloc (liste de composants) en un seul \'stage\' synth\u00E9tique.\r\n    Important : on calcule le NF et l\'OP1dB du bloc **en appliquant exactement**\r\n    les m\u00EAmes formules de cascade (calc_nf et calc_p1db) \u00E0 la sous-cha\u00EEne interne.\r\n    Cela \u00E9vite les approximations (somme na\u00EFve des NF qui faussent les r\u00E9sultats).\r\n\r\n    Retourne un dict avec:\r\n      - name, gain_dB (somme), gain_dB_max (somme), nf_dB (calc Friis sur sous-cha\u00EEne),\r\n        p1db_dBm (OP1dB du bloc), gain_lin, nf_lin, p1db_lin, type=\'block\'\r\n    \"\"\"\r\n    subchain = []\r\n    total_gain_dB = 0.0\r\n    total_gain_dB_max = 0.0\r\n\r\n    for comp in block:\r\n        # Pour les passifs (filter, switch) : on cherche insertion_loss_dB (positive)\r\n        # gain_comp_dB = - insertion_loss_dB ; nf_comp_dB = insertion_loss_dB\r\n        if comp.get(\'type\') in [\'filter\', \'switch\'] and \'insertion_loss_dB\' in comp:\r\n            loss = float(comp[\'insertion_loss_dB\'])\r\n            gain_comp_dB = -abs(loss)\r\n            nf_comp_dB = abs(loss)\r\n        else:\r\n            gain_comp_dB = float(comp.get(\'gain_dB\', 0.0))\r\n            nf_comp_dB = float(comp.get(\'nf_dB\', abs(gain_comp_dB)))\r\n\r\n        # p1db en dBm : accepte p1db_dBm ou op1db_dBm ; d\u00E9faut = +1000 dBm (non contraignant)\r\n        p1db_val = comp.get(\'p1db_dBm\', comp.get(\'op1db_dBm\', 1000.0))\r\n\r\n        # Construire l\'entr\u00E9e en lin\u00E9aire attendue par calc_nf \/ calc_p1db\r\n        substage = {\r\n            \'name\': comp.get(\'name\', \'\'),\r\n            \'type\': comp.get(\'type\', \'\'),\r\n            \'gain_lin\': db_to_lin(gain_comp_dB),\r\n            \'nf_lin\': db_to_lin(nf_comp_dB),\r\n            \'p1db_lin\': db_to_lin(float(p1db_val))\r\n        }\r\n        subchain.append(substage)\r\n\r\n        total_gain_dB += gain_comp_dB\r\n        total_gain_dB_max += float(comp.get(\'gain_dB_max\', gain_comp_dB))\r\n\r\n    # Calculs corrects par cascade sur la sous-cha\u00EEne\r\n    block_nf_dB = calc_nf(subchain)        # NF du bloc en dB (Friis)\r\n    block_p1db_dBm = calc_p1db(subchain)   # OP1dB du bloc en dBm\r\n\r\n    return {\r\n        \'name\': flatten_block_names(block),\r\n        \'gain_dB\': total_gain_dB,\r\n        \'gain_dB_max\': total_gain_dB_max,\r\n        \'nf_dB\': block_nf_dB,\r\n        \'p1db_dBm\': block_p1db_dBm,\r\n        \'gain_lin\': db_to_lin(total_gain_dB),\r\n        \'nf_lin\': db_to_lin(block_nf_dB),\r\n        \'p1db_lin\': db_to_lin(block_p1db_dBm),\r\n        \'type\': \'block\'\r\n    }\r\n\r\n# -------------------------\r\n# G\u00E9n\u00E9ration de toutes les architectures\r\n# -------------------------\r\ndef generate_all_chains(blocks, movable_lnas, attenuators):\r\n    \"\"\"\r\n    Ins\u00E8re les LNAs mobiles dans les positions possibles entre les blocs fixes,\r\n    puis ins\u00E8re les att\u00E9nuateurs (avec toutes les combinaisons de r\u00E9glages possibles).\r\n    Retourne une liste d\'architectures test\u00E9es avec m\u00E9triques de base.\r\n    \"\"\"\r\n    insert_positions = list(range(1, len(blocks)))  # positions entre blocs\r\n    all_architectures = []\r\n\r\n    # it\u00E8re sur choix de positions pour les LNAs mobiles\r\n    for lna_positions in itertools.combinations(insert_positions, len(movable_lnas)):\r\n        for lna_perm in itertools.permutations(movable_lnas):\r\n            temp_blocks = blocks.copy()\r\n            # ins\u00E8re les LNAs (on garde l\'ordre des positions)\r\n            for pos, lna in sorted(zip(lna_positions, lna_perm), reverse=True):\r\n                temp_blocks.insert(pos, lna.copy())\r\n\r\n            # pr\u00E9parer toutes les configurations d\'att\u00E9nuateurs (options)\r\n            att_configs_per_att = []\r\n            for att in attenuators:\r\n                att_configs = []\r\n                if \'gain_dB_options\' in att:\r\n                    for att_gain_dB in att[\'gain_dB_options\']:\r\n                        att_copy = att.copy()\r\n                        att_copy[\'gain_dB\'] = att_gain_dB\r\n                        att_copy[\'gain_lin\'] = db_to_lin(att_gain_dB)\r\n                        att_copy[\'nf_lin\'] = db_to_lin(abs(att_gain_dB))\r\n                        att_copy[\'p1db_lin\'] = db_to_lin(att_copy.get(\'p1db_dBm\', att_copy.get(\'op1db_dBm\', 1000)))\r\n                        att_configs.append(att_copy)\r\n                else:\r\n                    att_copy = att.copy()\r\n                    att_copy[\'gain_lin\'] = db_to_lin(att[\'gain_dB\'])\r\n                    att_copy[\'nf_lin\'] = db_to_lin(abs(att[\'gain_dB\']))\r\n                    att_copy[\'p1db_lin\'] = db_to_lin(att_copy.get(\'p1db_dBm\', att_copy.get(\'op1db_dBm\', 1000)))\r\n                    att_configs.append(att_copy)\r\n                att_configs_per_att.append(att_configs)\r\n\r\n            # positions possibles pour ins\u00E9rer les att\u00E9nuateurs\r\n            att_positions = list(range(1, len(temp_blocks)))\r\n            for att_pos_combo in itertools.combinations(att_positions, len(attenuators)):\r\n                for att_gain_combo in itertools.product(*att_configs_per_att):\r\n                    full_chain = temp_blocks.copy()\r\n                    # ins\u00E8re les att\u00E9nuateurs (en partant de la fin pour respecter positions)\r\n                    for pos, att in sorted(zip(att_pos_combo, att_gain_combo), reverse=True):\r\n                        full_chain.insert(pos, att)\r\n\r\n                    # garantir que les champs lin\u00E9aires sont pr\u00E9sents pour chaque stage\r\n                    for s in full_chain:\r\n                        if \'gain_lin\' not in s:\r\n                            s[\'gain_lin\'] = db_to_lin(s.get(\'gain_dB\', 0.0))\r\n                        if \'nf_lin\' not in s:\r\n                            s[\'nf_lin\'] = db_to_lin(s.get(\'nf_dB\', abs(s.get(\'gain_dB\', 0.0))))\r\n                        if \'p1db_lin\' not in s:\r\n                            p1db_val = s.get(\'p1db_dBm\', s.get(\'op1db_dBm\', 1000.0))\r\n                            s[\'p1db_lin\'] = db_to_lin(p1db_val)\r\n\r\n                    gain_lin = math.prod(stage[\'gain_lin\'] for stage in full_chain)\r\n                    gain_dB = lin_to_db(gain_lin)\r\n                    nf = calc_nf(full_chain)      # NF total en dB (Friis)\r\n                    p1db = calc_p1db(full_chain)  # OP1dB sortie en dBm\r\n\r\n                    all_architectures.append({\r\n                        \'chain\': [s[\'name\'] for s in full_chain],\r\n                        \'nf_dB\': nf,\r\n                        \'p1db_dBm\': p1db,   # OP1dB (sortie)\r\n                        \'gain_dB\': gain_dB,\r\n                        \'full_chain\': full_chain\r\n                    })\r\n    return all_architectures\r\n\r\n# -------------------------\r\n# Calcul min\/max (att\u00E9nuateurs)\r\n# -------------------------\r\ndef compute_metrics_gain_min_max(full_chain, attenuators):\r\n    \"\"\"\r\n    Construit deux variantes de la cha\u00EEne :\r\n      - chain_min : att\u00E9nuateurs \u00E0 leur valeur minimale (min gain_dB)\r\n      - chain_max : att\u00E9nuateurs \u00E0 leur valeur maximale (max gain_dB)\r\n    Puis calcule pour chaque variante :\r\n      - gain total (dB)\r\n      - NF total (dB)\r\n      - OP1dB sortie (dBm)\r\n    Enfin calcule IP1dB d\'entr\u00E9e :\r\n      IP1dB = OP1dB_sortie - Gain_total  (valeurs min\/max correspondantes)\r\n    Retour: gain_min_dB, gain_max_dB, nf_min, nf_max, p1db_min, p1db_max, ip1_min, ip1_max\r\n    \"\"\"\r\n    chain_max = []\r\n    chain_min = []\r\n\r\n    for stage in full_chain:\r\n        # traiter \u00E0 la fois \'atten\' et \'attenuator\'\r\n        if stage[\'type\'] in [\'attenuator\', \'atten\']:\r\n            s = stage.copy()\r\n            if \'gain_dB_options\' in s:\r\n                max_gain = max(s[\'gain_dB_options\'])\r\n                min_gain = min(s[\'gain_dB_options\'])\r\n            else:\r\n                max_gain = min_gain = s[\'gain_dB\']\r\n            s_max = s.copy()\r\n            s_max[\'gain_dB\'] = max_gain\r\n            s_max[\'gain_lin\'] = db_to_lin(max_gain)\r\n            s_max[\'nf_lin\'] = db_to_lin(abs(max_gain))\r\n\r\n            s_min = s.copy()\r\n            s_min[\'gain_dB\'] = min_gain\r\n            s_min[\'gain_lin\'] = db_to_lin(min_gain)\r\n            s_min[\'nf_lin\'] = db_to_lin(abs(min_gain))\r\n\r\n            chain_max.append(s_max)\r\n            chain_min.append(s_min)\r\n        else:\r\n            chain_max.append(stage)\r\n            chain_min.append(stage)\r\n\r\n    gain_max_lin = math.prod(s[\'gain_lin\'] for s in chain_max)\r\n    gain_max_dB = lin_to_db(gain_max_lin)\r\n    nf_max = calc_nf(chain_max)\r\n    p1db_max = calc_p1db(chain_max)\r\n\r\n    gain_min_lin = math.prod(s[\'gain_lin\'] for s in chain_min)\r\n    gain_min_dB = lin_to_db(gain_min_lin)\r\n    nf_min = calc_nf(chain_min)\r\n    p1db_min = calc_p1db(chain_min)\r\n\r\n    # IP1dB (entr\u00E9e) : OP1dB_sortie - gain_total (valeurs coh\u00E9rentes min\/max)\r\n    ip1_min = p1db_min - gain_min_dB\r\n    ip1_max = p1db_max - gain_max_dB\r\n\r\n    return gain_min_dB, gain_max_dB, nf_min, nf_max, p1db_min, p1db_max, ip1_min, ip1_max\r\n\r\n# -------------------------\r\n# Scoring\r\n# -------------------------\r\ndef score_architecture_metrics(metrics, target_gain, nf_max_target, p1db_min_target):\r\n    \"\"\"\r\n    Score = somme des erreurs quadratiques pond\u00E9r\u00E9es par les cibles :\r\n      - erreur sur gain min et max par rapport \u00E0 target_gain\r\n      - p\u00E9nalit\u00E9 si NF_max (cas pessimiste) d\u00E9passe nf_max_target\r\n      - p\u00E9nalit\u00E9 si OP1dB_min (cas pessimiste) est < p1db_min_target\r\n    NOTE : les IP1dB ne sont pas utilis\u00E9s dans le score actuel.\r\n    \"\"\"\r\n    gain_min, gain_max, nf_min, nf_max, p1db_min, p1db_max, ip1_min, ip1_max = metrics\r\n    err_gain_min = (gain_min - target_gain) ** 2\r\n    err_gain_max = (gain_max - target_gain) ** 2\r\n    err_nf = max(0, nf_max - nf_max_target) ** 2\r\n    err_p1db = max(0, p1db_min_target - p1db_min) ** 2\r\n    return err_gain_min + err_gain_max + err_nf + err_p1db\r\n\r\n# -------------------------\r\n# Main\r\n# -------------------------\r\ndef main():\r\n    # charge le YAML (attendu: \'components.yaml\' \u00E0 c\u00F4t\u00E9 du script)\r\n    config = load_config(\'components.yaml\')\r\n    target_gain = config[\'gain_total_target_dB\']\r\n    nf_max_target = config[\'nf_max_dB\']\r\n    p1db_min_target = config[\'p1db_min_dBm\']\r\n    components = config[\'components\']\r\n\r\n    # s\u00E9paration composants en listes : fixed (blocs immuables), lnas (mobiles), attenuators\r\n    fixed = []\r\n    lnas = []\r\n    attenuators = []\r\n\r\n    for comp in components:\r\n        comp = comp.copy()\r\n\r\n        # p1db peut \u00EAtre dans p1db_dBm ou op1db_dBm selon ton YAML -> unifier\r\n        p1db_val = comp.get(\'p1db_dBm\', comp.get(\'op1db_dBm\', None))\r\n        if p1db_val is None:\r\n            p1db_val = 1000.0  # valeur non contraignante si absent\r\n        comp[\'p1db_lin\'] = db_to_lin(p1db_val)\r\n\r\n        # traitement des att\u00E9nuateurs (options ou valeur fixe)\r\n        if comp[\'type\'] in [\'attenuator\', \'atten\']:\r\n            gain_ref = comp[\'gain_dB_options\'][0] if \'gain_dB_options\' in comp else comp[\'gain_dB\']\r\n            comp[\'gain_lin\'] = db_to_lin(gain_ref)\r\n            comp[\'nf_lin\'] = db_to_lin(abs(gain_ref))\r\n        else:\r\n            # si filtre\/switch : convertit insertion_loss_dB -> gain_dB n\u00E9gatif et nf\r\n            if comp.get(\'type\') in [\'filter\', \'switch\'] and \'insertion_loss_dB\' in comp:\r\n                loss = comp[\'insertion_loss_dB\']\r\n                comp[\'gain_dB\'] = -abs(loss)\r\n                comp[\'nf_dB\'] = loss\r\n            comp[\'gain_lin\'] = db_to_lin(comp.get(\'gain_dB\', 0.0))\r\n            comp[\'nf_lin\'] = db_to_lin(comp.get(\'nf_dB\', 30.0))\r\n\r\n        # classification\r\n        if comp[\'type\'] == \'lna\' and not comp.get(\'fixed\', False):\r\n            lnas.append(comp)\r\n        elif comp[\'type\'] in [\'attenuator\', \'atten\']:\r\n            if comp.get(\'fixed\', False):\r\n                fixed.append(comp)\r\n            else:\r\n                attenuators.append(comp)\r\n        else:\r\n            fixed.append(comp)\r\n\r\n    # grouper les composants fixes en blocs respectant locked_with_next\r\n    blocks = group_locked_stages(fixed)\r\n    block_stages = [flatten_block_stages(b) for b in blocks]\r\n\r\n    # g\u00E9n\u00E9rer toutes les architectures en ins\u00E9rant sous-ensembles de LNAs mobiles\r\n    all_archs = []\r\n    for lna_subset in non_empty_subsets(lnas):\r\n        archs = generate_all_chains(block_stages, lna_subset, attenuators)\r\n        all_archs.extend(archs)\r\n\r\n    if not all_archs:\r\n        print(\"\u274C Aucune architecture g\u00E9n\u00E9r\u00E9e.\")\r\n        return\r\n\r\n    # scorer chaque architecture et \u00E9crire r\u00E9sultats\r\n    scored_archs = []\r\n    for arch in all_archs:\r\n        metrics = compute_metrics_gain_min_max(arch[\'full_chain\'], attenuators)\r\n        score = score_architecture_metrics(metrics, target_gain, nf_max_target, p1db_min_target)\r\n        scored_archs.append({\r\n            \'chain\': arch[\'chain\'],\r\n            \'metrics\': metrics,\r\n            \'score\': score\r\n        })\r\n\r\n    # tri et sauvegarde\r\n    scored_archs_sorted = sorted(scored_archs, key=lambda a: a[\'score\'])\r\n    script_dir = os.path.dirname(os.path.abspath(__file__))\r\n    results_path = os.path.join(script_dir, \"results.txt\")\r\n    with open(results_path, \"w\", encoding=\"utf-8\") as f:\r\n        f.write(\"=== \uD83E\uDDEA Toutes les architectures test\u00E9es : {} ===\\n\\n\".format(len(scored_archs_sorted)))\r\n        for arch in scored_archs_sorted:\r\n            gain_min_dB, gain_max_dB, nf_min, nf_max, p1db_min, p1db_max, ip1_min, ip1_max = arch[\'metrics\']\r\n            f.write(f\"Cha\u00EEne: {arch[\'chain\']}\\n\")\r\n            f.write(f\"  -> Gain min = {gain_min_dB:.2f} dB | Gain max = {gain_max_dB:.2f} dB\\n\")\r\n            f.write(f\"     NF min   = {nf_min:.2f} dB    | NF max   = {nf_max:.2f} dB\\n\")\r\n            f.write(f\"     OP1dB sort. min = {p1db_min:.2f} dBm | OP1dB sort. max = {p1db_max:.2f} dBm\\n\")\r\n            f.write(f\"     IP1dB entr. min = {ip1_min:.2f} dBm | IP1dB entr. max = {ip1_max:.2f} dBm\\n\")\r\n            f.write(f\"     Score    = {arch[\'score\']:.4f}\\n\\n\")\r\n\r\n    # afficher meilleure architecture\r\n    best_arch = scored_archs_sorted[0]\r\n    gain_min_dB, gain_max_dB, nf_min, nf_max, p1db_min, p1db_max, ip1_min, ip1_max = best_arch[\'metrics\']\r\n\r\n    print(\"\\n=== \u2705 Meilleure architecture trouv\u00E9e ===\")\r\n    print(f\"Cha\u00EEne: {best_arch[\'chain\']}\\n\")\r\n    print(f\"Gain min (att\u00E9nuateurs \u00E0 min) : {gain_min_dB:.2f} dB\")\r\n    print(f\"Gain max (att\u00E9nuateurs \u00E0 max) : {gain_max_dB:.2f} dB\\n\")\r\n    print(f\"NF min (gain min)              : {nf_min:.2f} dB\")\r\n    print(f\"NF max (gain max)              : {nf_max:.2f} dB\\n\")\r\n    print(f\"OP1dB sortie (min)             : {p1db_min:.2f} dBm\")\r\n    print(f\"OP1dB sortie (max)             : {p1db_max:.2f} dBm\\n\")\r\n    print(f\"IP1dB entr\u00E9e (min)             : {ip1_min:.2f} dBm\")\r\n    print(f\"IP1dB entr\u00E9e (max)             : {ip1_max:.2f} dBm\\n\")\r\n    print(f\"Score                          : {best_arch[\'score\']:.4f}\\n\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
  "code_yaml": "# Fichier d\'entr\u00E9e pour le script : param\u00E8tres cibles et liste de composants\r\n# Units:\r\n#  - gains \/ pertes : dB\r\n#  - NF : dB\r\n#  - P1dB \/ OP1dB : dBm\r\n\r\n# Objectifs \/ contraintes globales que le script tente d\'atteindre\r\ngain_total_target_dB: 30     # cible de gain total (dB) recherch\u00E9e par le scoring\r\nnf_max_dB: 10               # NF max tol\u00E9r\u00E9 (dB) pour l\'architecture \"pessimiste\"\r\np1db_min_dBm: 0             # OP1dB minimal demand\u00E9 (dBm) \u2014 phase pessimiste\r\nlna_count: 4                # info utile (nombre total LNAs envisag\u00E9s) \u2014 non obligatoire\r\n\r\ncomponents:\r\n  # Composants \"fixes\" (seront group\u00E9s en blocs si locked_with_next=True)\r\n  - name: \"preselector\"\r\n    type: \"filter\"\r\n    gain_dB: -5              # ici on utilise gain_dB n\u00E9gatif ; si tu pr\u00E9f\u00E8res insertion_loss_dB: 5\r\n    nf_dB: 5                 # NF pour les passifs (dans notre convention NF = perte d\'insertion)\r\n    p1db_dBm: 25             # OP1dB du composant en dBm\r\n    fixed: true              # composant fixe (non d\u00E9plac\u00E9 par l\'algorithme)\r\n\r\n  - name: \"ImageFilter\"\r\n    type: \"filter\"\r\n    gain_dB: -8.49\r\n    nf_dB: 8.49\r\n    p1db_dBm: 17.35\r\n    fixed: true\r\n\r\n  - name: \"ATT-3dB fixe\"\r\n    type: attenuator\r\n    gain_dB: -3.0\r\n    nf_dB: 3.0\r\n    p1db_dBm: 20\r\n    fixed: true\r\n    locked_with_next: true   # verrouille ce composant avec le suivant dans le m\u00EAme bloc\r\n                             # (utile pour regrouper ATT + Mixer + OL_Filter en un bloc)\r\n\r\n  - name: \"Mixer\"\r\n    type: \"mixer\"\r\n    gain_dB: -6.83\r\n    nf_dB: 7.5\r\n    p1db_dBm: 14\r\n    fixed: true\r\n    locked_with_next: true\r\n\r\n  - name: \"OL_Filter\"\r\n    type: \"filter\"\r\n    gain_dB: -0.63\r\n    nf_dB: 0.63\r\n    p1db_dBm: 20\r\n    fixed: true\r\n\r\n  - name: \"Switch\"\r\n    type: attenuator\r\n    gain_dB: -2.0\r\n    nf_dB: 2.0\r\n    p1db_dBm: 25\r\n    fixed: true\r\n    locked_with_next: true   # verrouille Switch avec le passe_bande suivant\r\n\r\n  - name: \"passe_bande\"\r\n    type: \"filter\"\r\n    gain_dB: -0.7\r\n    nf_dB: 0.7\r\n    p1db_dBm: 25\r\n    fixed: true\r\n\r\n  # LNAs mobiles \u2014 l\'algorithme testera diff\u00E9rentes positions pour ces \u00E9l\u00E9ments\r\n  - name: \"LNA1\"\r\n    type: \"lna\"\r\n    gain_dB: 15.3\r\n    nf_dB: 3.5\r\n    p1db_dBm: 23.94\r\n    fixed: false\r\n\r\n  - name: \"LNA2\"\r\n    type: \"lna\"\r\n    gain_dB: 15.3\r\n    nf_dB: 3\r\n    p1db_dBm: 23.94\r\n    fixed: false\r\n\r\n  - name: \"LNA3\"\r\n    type: \"lna\"\r\n    gain_dB: 27\r\n    nf_dB: 1\r\n    p1db_dBm: 12.4\r\n    fixed: false\r\n\r\n  # Att\u00E9nuateur variable \u2014 on fournit les options disponibles (le script testera les 2 positions)\r\n  - name: \"ATT\"\r\n    type: \"attenuator\"\r\n    gain_dB_options: [-3, -30]   # options d\'att\u00E9nuation que l\'on peut s\u00E9lectionner\r\n    nf_dB: 30                    # NF renseign\u00E9 (ici j\'ai mis 30 dB pour forcer la p\u00E9nalit\u00E9 si utilis\u00E9)\r\n    p1db_dBm: 22\r\n    fixed: false                 # att\u00E9nuateur mobile: script pourra l\'ins\u00E9rer entre blocs\r\n\r\n  - name: \"LNA4\"\r\n    type: \"lna\"\r\n    gain_dB: 15.3\r\n    nf_dB: 3\r\n    p1db_dBm: 23.94\r\n    fixed: false\r\n",
  "code_path": "files/code/Architecture_finder/Architecture_finder.py",
  "yaml_path": "files/code/Architecture_finder/components.yaml"
},
{
  "filename": "code/Spurious_finder.zip",
  "title": "Spurious Finder",
  "category": "algorithme",
  "version": "code",
  "size_bytes": 15612,
  "description": "Calcul des produits de mélange d'un mixer.",
  "code_py":"# -*- coding: utf-8 -*-\r\n\"\"\"\r\nScript d\'analyse rapide d\'une cha\u00EEne RF d\u00E9crite en YAML.\r\n- calcule NF total (Loi de Friis)\r\n- calcule OP1dB de sortie (combinaison en lin\u00E9aire)\r\n- affiche un r\u00E9sum\u00E9 color\u00E9 en console\r\n\r\nConventions attendues pour le YAML (exemple) :\r\narchitecture:\r\n  - name: \"LNA1\"\r\n    type: \"ampli\"\r\n    gain_dB: 15                 # gain nominal (dB)\r\n    gain_dB_max: 17             # (optionnel) gain max si different\r\n    nf_dB: 2.0                  # (optionnel) figure de bruit (dB)\r\n    op1db_dBm: 5                # (optionnel) OP1dB en dBm\r\n  - name: \"Filt1\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 2.5      # pour les filtres on fournit la perte (positive)\r\n    # ...\r\nAttention :\r\n- Les unit\u00E9s : gains et pertes en dB, NF en dB, OP1dB en dBm.\r\n- Le code convertit en lin\u00E9aire pour les calculs (rapports lin\u00E9aires, puissances en mW).\r\n- Valeurs manquantes ont des comportements par d\u00E9faut (voir build_chain).\r\n\"\"\"\r\n\r\nimport yaml\r\nimport math\r\nimport os\r\nfrom colorama import init, Fore, Back, Style\r\n\r\n# Active colorama (r\u00E9initialisation automatique des styles apr\u00E8s chaque print)\r\ninit(autoreset=True)\r\n\r\n# Couleurs pour affichage par type d\'\u00E9tage (simple mapping visuel)\r\n# - \'ampli\'  : rouge\r\n# - \'filter\' : cyan\r\n# - \'atten\'  : jaune\r\n# - \'switch\' : vert\r\n# - \'mixer\'  : magenta\r\nTYPE_COLORS = {\r\n    \'ampli\':   Fore.RED + Style.BRIGHT,\r\n    \'filter\':  Fore.CYAN + Style.BRIGHT,\r\n    \'atten\':   Fore.YELLOW + Style.BRIGHT,\r\n    \'switch\':  Fore.GREEN + Style.BRIGHT,\r\n    \'mixer\':   Fore.MAGENTA + Style.BRIGHT,\r\n}\r\n\r\n# ---------- Fonctions utilitaires (conversion dB <-> lin\u00E9aire) ----------\r\n\r\ndef db_to_lin(db):\r\n    \"\"\"\r\n    Convertit une valeur en dB vers une valeur lin\u00E9aire (facteur ou mW selon le contexte).\r\n    - entr\u00E9e : valeur en dB (ou dBm si contexte puissance)\r\n    - sortie : 10^(db\/10)\r\n\r\n    Exemple :\r\n      10 dB  -> 10\r\n      -3 dB  -> 0.5\r\n      0 dBm  -> 1 mW  (utilis\u00E9 pour convertir dBm -> mW)\r\n    Attention : appeler cette fonction sur des valeurs tr\u00E8s grandes (ex : 1000) produit des floats tr\u00E8s grands.\r\n    \"\"\"\r\n    return 10 ** (db \/ 10)\r\n\r\n\r\ndef lin_to_db(lin):\r\n    \"\"\"\r\n    Convertit une valeur lin\u00E9aire vers dB.\r\n    - si lin est un ratio (ex : gain lin\u00E9aire) la sortie est en dB.\r\n    - si lin est en mW, la sortie est en dBm (0 dBm => 1 mW).\r\n    Formule : 10 * log10(lin)\r\n    \"\"\"\r\n    return 10 * math.log10(lin)\r\n\r\n# ---------- Calcul de la figure de bruit totale (Friis) ----------\r\n\r\ndef calc_nf(chain):\r\n    \"\"\"\r\n    Calcule la NF totale (en dB) d\'une cha\u00EEne donn\u00E9e.\r\n    Entr\u00E9e : chain = liste d\'\u00E9tages, chaque \u00E9l\u00E9ment doit contenir :\r\n      - \'nf_lin\'   : NF en lin\u00E9aire (pas en dB)\r\n      - \'gain_lin\' : gain (lin\u00E9aire, ratio de puissance)\r\n    Algorithme : formule de Friis :\r\n      NF_tot_lin = NF1 + (NF2 - 1)\/G1 + (NF3 - 1)\/(G1*G2) + ...\r\n    Retour : NF totale en dB (utilise lin_to_db).\r\n    Remarque : la 1\u00E8re NF doit \u00EAtre en lin\u00E9aire et non nulle.\r\n    \"\"\"\r\n    # NF lin\u00E9aire du premier \u00E9tage\r\n    nf_tot = chain[0][\'nf_lin\']\r\n    # produit cumulatif des gains (lin\u00E9aire) des \u00E9tages d\u00E9j\u00E0 rencontr\u00E9s\r\n    g_prod = chain[0][\'gain_lin\']\r\n    # boucle sur les \u00E9tages suivants\r\n    for stage in chain[1:]:\r\n        nf_tot += (stage[\'nf_lin\'] - 1) \/ g_prod\r\n        g_prod *= stage[\'gain_lin\']\r\n    return lin_to_db(nf_tot)\r\n\r\n# ---------- Calcul de l\'OP1dB total en sortie ----------\r\n\r\ndef calc_p1db(chain):\r\n    \"\"\"\r\n    Calcule l\'OP1dB de sortie d\'une cha\u00EEne (en dBm).\r\n    M\u00E9thode :\r\n      - p1db_lin : OP1dB de chaque \u00E9tage en mW (lin\u00E9aire)\r\n      - gain_after[i] : produit des gains lin\u00E9aires des \u00E9tages plac\u00E9s APR\u00C8S l\'\u00E9tage i\r\n      - contribution d\'un \u00E9tage i au P1dB total (en mW) est P1dB_i * gain_after[i]\r\n      - on somme les inverses : 1 \/ P_total = sum_i 1\/(P1dB_i * gain_after[i])\r\n      - P_total (mW) = 1 \/ somme_inverse\r\n      - retour en dBm via lin_to_db (car lin_to_db( mW ) -> dBm)\r\n    Hypoth\u00E8ses \/ limites :\r\n      - si un p1db_lin est nul ou manquant, cela l\u00E8vera une ZeroDivisionError.\r\n      - s\'assurer que gains et p1db sont en lin\u00E9aire avant l\'appel.\r\n    \"\"\"\r\n    N = len(chain)\r\n    gain_after = [1.0] * N  # gain total plac\u00E9 apr\u00E8s chaque \u00E9tage (lin\u00E9aire)\r\n    prod = 1.0\r\n    # construire gain_after en sens inverse : gain_after[i] = produit(gain_k pour k>i)\r\n    for idx in range(N-1, -1, -1):\r\n        gain_after[idx] = prod\r\n        prod *= chain[idx][\'gain_lin\']\r\n\r\n    # somme des inverses pond\u00E9r\u00E9es\r\n    inv_sum = sum(\r\n        1 \/ (stage[\'p1db_lin\'] * gain_after[i])\r\n        for i, stage in enumerate(chain)\r\n    )\r\n    # r\u00E9sultat en mW -> lin_to_db retourne dBm\r\n    return lin_to_db(1 \/ inv_sum)\r\n\r\n# ---------- Construction de la cha\u00EEne RF depuis le YAML ----------\r\n\r\ndef build_chain(arch, use_gain_max=False):\r\n    \"\"\"\r\n    Transforme la description YAML (valeurs en dB\/dBm) en une liste d\'\u00E9tages avec valeurs lin\u00E9aires.\r\n    Param\u00E8tres :\r\n      - arch : liste d\'\u00E9l\u00E9ments YAML d\u00E9crivant chaque composant\r\n      - use_gain_max : si True, pr\u00E9f\u00E8re \'gain_dB_max\' si pr\u00E9sent, sinon \'gain_dB\'\r\n\r\n    Comportements particuliers :\r\n      - Pour les filtres et switches, on consid\u00E8re que la NF (en dB) = perte d\'insertion (insertion_loss_dB).\r\n        => gain_dB = - insertion_loss_dB  (car perte)\r\n      - Si nf_dB absent pour un amplificateur, on prend nf_dB = |gain_dB| (approximation conservative)\r\n      - Si op1db_dBm absent, valeur par d\u00E9faut distante (ici 1000 dBm) -> attention overflow possible si converti en mW\r\n        (la valeur 1000 sert d\'indicateur \"virtuel\" d\'absence de contrainte ; c\'est une pratique risqu\u00E9e en calculs r\u00E9els)\r\n    Retour :\r\n      liste de dicts : { \'name\', \'type\', \'gain_lin\', \'nf_lin\', \'p1db_lin\' }\r\n      - gain_lin : facteur (unitless)\r\n      - nf_lin   : ratio lin\u00E9aire (>1)\r\n      - p1db_lin : puissance en mW (lin\u00E9aire)\r\n    \"\"\"\r\n    chain = []\r\n    for c in arch:\r\n        # si composant passif de filtrage => perte fournie\r\n        if c[\'type\'] in [\'filter\', \'switch\']:\r\n            loss = c[\'insertion_loss_dB\']  # valeur positive (dB)\r\n            gain_dB = -loss                 # gain = -perte\r\n            nf_dB = loss                    # NF d\'un passif = perte d\'insertion\r\n        else:\r\n            # choisir gain nominal ou gain max selon le mode\r\n            gain_dB = c.get(\'gain_dB_max\', c[\'gain_dB\']) if use_gain_max else c[\'gain_dB\']\r\n            # NF fourni ou estimation conservatrice (abs(gain_dB))\r\n            nf_dB = c.get(\'nf_dB\', abs(gain_dB))\r\n\r\n        # OP1dB : si pr\u00E9sent, valeur en dBm ; sinon 1000 (valeur par d\u00E9faut)\r\n        # NOTE : 1000 dBm -> db_to_lin(1000) fera 10**(100) -> tr\u00E8s grand float\r\n        p1dB = c.get(\'op1db_dBm\', 1000)\r\n\r\n        chain.append({\r\n            \'name\': c[\'name\'],\r\n            \'type\': c[\'type\'],\r\n            \'gain_lin\': db_to_lin(gain_dB),\r\n            \'nf_lin\': db_to_lin(nf_dB),\r\n            \'p1db_lin\': db_to_lin(p1dB)\r\n        })\r\n    return chain\r\n\r\n# ---------- Fonctions d\'affichage console (color\u00E9es) ----------\r\n\r\ndef print_header(title):\r\n    \"\"\"\r\n    Print d\'un en-t\u00EAte simple (fond noir + texte blanc).\r\n    \"\"\"\r\n    print(Back.BLACK + Fore.WHITE + f\"  {title}  \" + Style.RESET_ALL)\r\n\r\n\r\ndef print_section(title, value, unit, color=Fore.WHITE):\r\n    \"\"\"\r\n    Affiche une ligne de synth\u00E8se format\u00E9e.\r\n    Exemple :\r\n      \u25A0\u25A0 Gain total   : 10.00 dB\r\n    - title : texte court\r\n    - value : valeur num\u00E9rique\r\n    - unit  : unit\u00E9 en texte (ex: \"dB\", \"dBm\")\r\n    - color : couleur (optionnel)\r\n    \"\"\"\r\n    bar = \'\u25A0\' * 3\r\n    print(f\"{color}{bar} {title:<15}: {value:>6.2f} {unit}{Style.RESET_ALL}\")\r\n\r\n\r\ndef print_spacers():\r\n    \"\"\"\r\n    Ligne de s\u00E9paration visuelle.\r\n    \"\"\"\r\n    print(\"_\" * 60 + \"\\n\")\r\n\r\n# ---------- Main \/ point d\'entr\u00E9e ----------\r\n\r\ndef main():\r\n    \"\"\"\r\n    Flux principal :\r\n    - charge YAML param.yaml situ\u00E9 dans le m\u00EAme dossier que ce script\r\n    - construit deux cha\u00EEnes (mode min \/ mode max si gain_dB_max fourni)\r\n    - calcule : NF total (min\/max), OP1dB sortie (min\/max), gains totaux (min\/max), IP1dB entr\u00E9e\r\n    - affiche le tout\r\n    \"\"\"\r\n    # chemin vers param.yaml dans le m\u00EAme dossier que ce script\r\n    base = os.path.dirname(os.path.abspath(__file__))\r\n    path = os.path.join(base, \"param.yaml\")\r\n    yaml_filename = os.path.basename(path)\r\n    print(f\"Fichier YAML ex\u00E9cut\u00E9 : {Fore.CYAN}{yaml_filename}{Style.RESET_ALL}\")\r\n\r\n    # chargement YAML\r\n    with open(path, \'r\') as f:\r\n        data = yaml.safe_load(f)\r\n    arch = data[\'architecture\']\r\n\r\n    # construire cha\u00EEnes min \/ max\r\n    ch_min = build_chain(arch, use_gain_max=False)\r\n    ch_max = build_chain(arch, use_gain_max=True)\r\n\r\n    # calculs principaux\r\n    nf_min, nf_max = calc_nf(ch_min), calc_nf(ch_max)\r\n    p1_min, p1_max = calc_p1db(ch_min), calc_p1db(ch_max)\r\n\r\n    # gains totaux (dB) : produit des gains lin\u00E9aires pass\u00E9 en dB\r\n    g_min = lin_to_db(math.prod(s[\'gain_lin\'] for s in ch_min))\r\n    g_max = lin_to_db(math.prod(s[\'gain_lin\'] for s in ch_max))\r\n\r\n    # IP1dB entr\u00E9e = OP1dB_sortie - Gain_total\r\n    ip1_min, ip1_max = p1_min - g_min, p1_max - g_max\r\n\r\n    # affichage cha\u00EEne (avec couleurs par type)\r\n    line = \" \u2192 \".join(f\"{TYPE_COLORS.get(s[\'type\'], \'\')}{s[\'name\']}{Style.RESET_ALL}\" for s in ch_min)\r\n\r\n    print_spacers()\r\n    print(f\"{Back.BLACK+Fore.WHITE}{\'\u25A0\'*3} {\'Cha\u00EEne RF\':<8}:{Style.RESET_ALL} {line}\\n\")\r\n    print_spacers()\r\n\r\n    # r\u00E9sultats\r\n    print(f\"{Back.BLACK+Fore.WHITE} R\u00E9sultats (min & max):{Style.RESET_ALL}\\n\")\r\n    # Gains\r\n    print_section(\"Gain total (min)   \", g_min, \"dB\")\r\n    print_section(\"Gain total (max)  \", g_max, \"dB\")\r\n    print()\r\n    # NF\r\n    print_section(\"NF total (min)     \", nf_min, \"dB\")\r\n    print_section(\"NF total (max)     \", nf_max, \"dB\")\r\n    print()\r\n    # OP1dB sortie\r\n    print_section(\"OP1dB sortie (min) \", p1_min, \"dBm\")\r\n    print_section(\"OP1dB sortie (max) \", p1_max, \"dBm\")\r\n    print()\r\n    # IP1dB entr\u00E9e\r\n    print_section(\"IP1dB entr\u00E9e (min) \", ip1_min, \"dBm\")\r\n    print_section(\"IP1dB entr\u00E9e (max) \", ip1_max, \"dBm\")\r\n    print_spacers()\r\n\r\n# Ex\u00E9cution quand lanc\u00E9 directement\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
  "code_yaml":"# Fichier YAML d\'architecture pour le script d\'analyse (param.yaml)\r\n# Format attendu : racine \"architecture\" = liste d\'\u00E9tages dans l\'ordre du parcours du signal.\r\n# Chaque entr\u00E9e repr\u00E9sente un composant\/\u00E9tage. Les champs utilis\u00E9s par le script :\r\n#   - name:           nom (cha\u00EEne)\r\n#   - type:           \'ampli\' | \'filter\' | \'atten\' | \'switch\' | \'mixer\'\r\n#   - gain_dB:        gain en dB (pour les amplis) OR gain n\u00E9gatif pour att\u00E9nuateur\r\n#   - gain_dB_max:    (optionnel) gain max si disponible (permet mode \"max\")\r\n#   - insertion_loss_dB: (pour filter\/switch) perte positive en dB\r\n#   - nf_dB:          figure de bruit en dB (pour amplis\/mixers) \u2014 si absent, on estime\r\n#   - op1db_dBm:      OP1dB en dBm (output 1 dB compression point)\r\n#\r\n# IMPORTANTS :\r\n# - Toutes les puissances\/gains\/pertes sont en dB ou dBm (unit\u00E9s strictes).\r\n# - Pour les filtres\/switch, insertion_loss_dB doit \u00EAtre positive (ex : 1.2 dB).\r\n# - Pour les att\u00E9nuateurs : gain_dB doit \u00EAtre n\u00E9gatif (ex : -30).\r\n# - Si une cl\u00E9 manquante existe, le script applique des valeurs par d\u00E9faut (v\u00E9rifier build_chain).\r\n# - Eviter d\'utiliser des valeurs extr\u00EAmes (ex : op1db_dBm = 1000), le script en fera un nombre lin\u00E9aire \u00E9norme.\r\n\r\narchitecture:\r\n\r\n  # ---------------------------\r\n  # Filtre passe-haut centr\u00E9 sur FI (exemple)\r\n  # - type: filter => script lit insertion_loss_dB (positif)\r\n  # - NF du passif = insertion_loss_dB (convention physique)\r\n  # - op1db_dBm renseign\u00E9 pour tra\u00E7abilit\u00E9 (valeur d\'usage)\r\n  # ---------------------------\r\n  - name: \"HPF_4GHz\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 0.61      # perte d\'insertion (dB). Doit \u00EAtre positive.\r\n    op1db_dBm: 20               # OP1dB du bloc (dBm) \u2014 utile pour calculs de cha\u00EEne\r\n\r\n  # ---------------------------\r\n  # Switch RF ; trait\u00E9 comme un passif (insertion_loss_dB)\r\n  # - type: switch => insertion_loss_dB positive\r\n  # - op1db_dBm : tenue en puissance \/ saturation (dBm)\r\n  # ---------------------------\r\n  - name: \"Switch\"\r\n    type: \"switch\"\r\n    insertion_loss_dB: 0.85\r\n    op1db_dBm: 25\r\n\r\n  # Pr\u00E9-filtre passe-haut (pr\u00E9-s\u00E9lection)\r\n  - name: \"Pre-HPF\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 1.179\r\n    op1db_dBm: 20\r\n\r\n  # Pr\u00E9-filtre passe-bas (pr\u00E9-s\u00E9lection)\r\n  - name: \"Pre-LPF\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 0.819\r\n    op1db_dBm: 20\r\n\r\n  # autre switch (ex : routage vers banque de filtres)\r\n  - name: \"Switch\"\r\n    type: \"switch\"\r\n    insertion_loss_dB: 0.85\r\n    op1db_dBm: 25\r\n\r\n  # ---------------------------\r\n  # Amplificateur faible bruit (LNA1)\r\n  # - type: ampli => fournir gain_dB et nf_dB\r\n  # - op1db_dBm : OP1dB de sortie (dBm)\r\n  # ---------------------------\r\n  - name: \"LNA1\"\r\n    type: \"ampli\"\r\n    gain_dB: 15.3                # gain nominal en dB\r\n    nf_dB: 3.5                   # figure de bruit en dB\r\n    op1db_dBm: 23.94             # OP1dB sortie (dBm)\r\n\r\n  # ---------------------------\r\n  # Att\u00E9nuateur variable simul\u00E9 par entr\u00E9e param\u00E9tr\u00E9e\r\n  # - type: atten => gain_dB n\u00E9gatif\r\n  # - gain_dB_max : utile si l\'att\u00E9nuateur peut \u00EAtre r\u00E9duit (ex : -5 dB en position minimale)\r\n  # ---------------------------\r\n  - name: \"ATT_30dB\"\r\n    type: \"atten\"\r\n    gain_dB: -30                 # position nominale (dB) -> valeur n\u00E9gative\r\n    gain_dB_max: -5              # meilleur cas (moins d\'att\u00E9nuation)\r\n    op1db_dBm: 20\r\n\r\n  # Deuxi\u00E8me LNA (apr\u00E8s att\u00E9nuateur)\r\n  - name: \"LNA2\"\r\n    type: \"ampli\"\r\n    gain_dB: 15.3\r\n    nf_dB: 3.5\r\n    op1db_dBm: 23.94\r\n\r\n  # ---------------------------\r\n  # Filtre image (pr\u00E9-s\u00E9lection) : valeurs typiques de perte fournies\r\n  # - insertion_loss_dB : perte dans la bande passante (dB)\r\n  # - op1db_dBm : tenue en puissance\r\n  # ---------------------------\r\n  - name: \"ImageFilter\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 8.7\r\n    op1db_dBm: 17.35\r\n\r\n  # Att\u00E9nuateur fixe 3 dB devant le mixer\r\n  - name: \"ATT-3dB\"\r\n    type: \"atten\"\r\n    gain_dB: -3\r\n    gain_dB_max: -3\r\n    op1db_dBm: 20\r\n\r\n  # ---------------------------\r\n  # Mixer : conversion loss (gain_dB n\u00E9gatif), NF approximatif\r\n  # - gain_dB : conversion loss (dB)\r\n  # - nf_dB : estimation de la contribution du mixer (dB)\r\n  # - op1db_dBm : OP1dB d\'entr\u00E9e ou de sortie selon la doc (ici consid\u00E9r\u00E9 comme sortie)\r\n  # ---------------------------\r\n  - name: \"Mixer\"\r\n    type: \"mixer\"\r\n    gain_dB: -6.83               # perte de conversion (dB) \u2014 valeur n\u00E9gative attendue\r\n    nf_dB: 7.5                   # figure de bruit indicative pour le mixeur (dB)\r\n    op1db_dBm: 14\r\n\r\n  # Filtre OL (passif)\r\n  - name: \"OL_Filter\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 0.67\r\n    op1db_dBm: 20\r\n\r\n  # LNA apr\u00E8s FI (gain \u00E9lev\u00E9 pour compenser pertes)\r\n  - name: \"LNA3\"\r\n    type: \"ampli\"\r\n    gain_dB: 22.5\r\n    nf_dB: 2.5\r\n    op1db_dBm: 22\r\n\r\n  # Autre att\u00E9nuateur (positionnement \/ contr\u00F4le)\r\n  - name: \"ATT_30dB\"\r\n    type: \"atten\"\r\n    gain_dB: -30\r\n    gain_dB_max: -12\r\n    op1db_dBm: 20\r\n\r\n  # Equalizer \/ switch (passif)\r\n  - name: \"Equalizer\"\r\n    type: \"switch\"\r\n    insertion_loss_dB: 2\r\n    op1db_dBm: 25\r\n\r\n  # LNA final\r\n  - name: \"LNA4\"\r\n    type: \"ampli\"\r\n    gain_dB: 20.5\r\n    nf_dB: 2.5\r\n    op1db_dBm: 31.7\r\n\r\n  # Briques du filtre FI (500 MHz BW) - passe-haut et passe-bas pour former le BPF\r\n  - name: \"500MHz-HPF\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 1\r\n    op1db_dBm: 23\r\n\r\n  - name: \"500MHz-LPF\"\r\n    type: \"filter\"\r\n    insertion_loss_dB: 1\r\n    op1db_dBm: 23\r\n\r\n# ---------------------------\r\n# Notes g\u00E9n\u00E9rales et conseils pratiques (ne pas oublier) :\r\n# - V\u00E9rifier que les champs obligatoires existent pour chaque type.\r\n#   * filter\/switch : insertion_loss_dB obligatoire.\r\n#   * ampli\/mixer : gain_dB obligatoire ; nf_dB fortement recommand\u00E9.\r\n#   * atten  : gain_dB n\u00E9gatif obligatoire.\r\n# - Un OP1dB manquant dans le YAML conduit le script \u00E0 utiliser une valeur par d\u00E9faut (voir code).\r\n#   C\'est dangereux : mieux vaut renseigner syst\u00E9matiquement op1db_dBm.\r\n# - Pour les filtres passifs, NF = insertion_loss_dB (en dB) est la convention utilis\u00E9e ici.\r\n# - Eviter d\'utiliser le m\u00EAme \"name\" plusieurs fois si l\'on veut les distinguer (bien que ce soit accept\u00E9).\r\n# - Les valeurs fournies ici sont des exemples\/mesures : adapter selon les datasheets des composants r\u00E9els.\r\n# - Si le script doit mod\u00E9liser des \u00E9l\u00E9ments variables (ex : att\u00E9nuateur r\u00E9glable, filtre accordable),\r\n#   utiliser gain_dB_max\/gain_dB comme fourchette et lancer le script en mode use_gain_max=True pour l\'\u00E9tudier.\r\n#\r\n# Suggestions d\'am\u00E9lioration :\r\n# - ajouter une cl\u00E9 \"comment\" ou \"ref\" pour lier l\'entr\u00E9e YAML \u00E0 la r\u00E9f\u00E9rence du composant (r\u00E9f\u00E9rence fournisseur).\r\n# - ajouter \"freq_range: [f_min_MHz, f_max_MHz]\" pour caract\u00E9riser la bande d\'op\u00E9ration d\'un composant.\r\n# - valider le YAML \u00E0 l\'ouverture et refuser les valeurs absurdes (ex : op1db_dBm > 50 dBm ou insertion_loss < 0).\r\n",
  "code_path": "files/code/Spurious_finder/Spurious_finder.py",
  "yaml_path": "files/code/Spurious_finder/parametres_spurious.yaml"
},
{
  "filename": "code/Architecture_verif.zip",
  "title": "Vérification Architecture",
  "category": "algorithme",
  "version": "code",
  "size_bytes": 15612,
  "description": "Calcul NF, gain, P1dB en cascade.",
  "code_py":"# -*- coding: utf-8 -*-\r\n\"\"\"\r\nAnalyse des fr\u00E9quences RF \u2014 script final Juillet 2025 (version robuste)\r\nBut :\r\n- calculer les plages RF susceptibles de g\u00E9n\u00E9rer des produits de m\u00E9lange (m,n)\r\n- calculer et afficher la plage de fr\u00E9quence image (supradyne\/infradyne)\r\n- trier\/filtrer les spurious et g\u00E9n\u00E9rer un rapport texte\r\nModifications apport\u00E9es :\r\n- recherche du fichier YAML dans le m\u00EAme dossier que le script (__file__)\r\n- \u00E9criture du fichier TXT de sortie dans le m\u00EAme dossier que le script\r\n- messages d\'erreur clairs si YAML absent ou mal form\u00E9\r\nRemarques :\r\n- Toutes les fr\u00E9quences sont en MHz.\r\n- La convention d\'indexation pour la table de puissances est expliqu\u00E9e dans get_puissance().\r\n\"\"\"\r\n\r\nfrom pathlib import Path\r\nimport sys\r\nimport yaml\r\nfrom typing import List, Optional, Tuple\r\n\r\n# ---------------------------\r\n# Fonctions utilitaires\r\n# ---------------------------\r\n\r\ndef charger_parametres_yaml(fichier_yaml: str) -> dict:\r\n    \"\"\"Charge et renvoie le contenu YAML sous forme de dict Python.\r\n    L\u00E8ve une exception si le fichier est introuvable ou invalide.\"\"\"\r\n    p = Path(fichier_yaml)\r\n    if not p.exists():\r\n        raise FileNotFoundError(f\"Fichier YAML introuvable : {p}\")\r\n    with p.open(\"r\", encoding=\"utf-8\") as f:\r\n        try:\r\n            data = yaml.safe_load(f)\r\n        except yaml.YAMLError as e:\r\n            raise RuntimeError(f\"Erreur lecture YAML : {e}\") from e\r\n    if not isinstance(data, dict):\r\n        raise ValueError(\"Le fichier YAML doit contenir un mapping (dictionnaire) en racine.\")\r\n    return data\r\n\r\n\r\ndef get_puissance(m: int, n: int, table: Optional[List[List]]) -> Optional[float]:\r\n    \"\"\"\r\n    R\u00E9cup\u00E8re la puissance (dBc) dans la table \'puissance_spurious\' pour (m,n).\r\n    Convention d\'indexation (code actuel) :\r\n      - ligne index = abs(m) - 1  -> ligne 0 correspond \u00E0 |m| == 1\r\n      - colonne index = abs(n)    -> colonne 0 correspond \u00E0 n == 0\r\n    Exemples :\r\n      m = -1, n = 2  -> table[0][2]\r\n      m = 2,  n = 0  -> table[1][0]\r\n    Retourne None si valeur absente \/ invalide \/ hors borne.\r\n    \"\"\"\r\n    if table is None:\r\n        return None\r\n    im = abs(m) - 1\r\n    in_ = abs(n)\r\n    # v\u00E9rification bornes\r\n    if im < 0 or im >= len(table):\r\n        return None\r\n    # certaines lignes pourraient avoir longueur in\u00E9gale -> safe check\r\n    if in_ < 0 or in_ >= len(table[im]):\r\n        return None\r\n    val = table[im][in_]\r\n    # valeurs \'ref\' ou \'na\' consid\u00E9r\u00E9es comme non fournies\r\n    if isinstance(val, str) and val.lower() in {\"ref\", \"na\"}:\r\n        return None\r\n    try:\r\n        return float(val)\r\n    except (ValueError, TypeError):\r\n        return None\r\n\r\n\r\n# ---------------------------\r\n# Calculs principaux\r\n# ---------------------------\r\n\r\ndef calculer_plage_image(params: dict) -> Tuple[float, float]:\r\n    \"\"\"\r\n    Calcule la plage de fr\u00E9quence image (en MHz) bas\u00E9e sur l\'OL fixe et la bande FI.\r\n    \'from\' accepte \'supradyne\' (OL + FI) ou \'infradyne\' (OL - FI).\r\n    \"\"\"\r\n    OL = params[\"OL_fixe_MHz\"]\r\n    FI_min = params[\"FI_min_MHz\"]\r\n    FI_max = params[\"FI_max_MHz\"]\r\n    mode = params.get(\"from\", \"supradyne\").lower().strip()\r\n    if mode == \"supradyne\":\r\n        return OL + FI_min, OL + FI_max\r\n    elif mode == \"infradyne\":\r\n        return OL - FI_max, OL - FI_min\r\n    else:\r\n        raise ValueError(\"Mode de conversion invalide (attendu \'supradyne\' ou \'infradyne\')\")\r\n\r\n\r\ndef calculer_plages(params: dict) -> List[dict]:\r\n    \"\"\"\r\n    Parcourt tous les couples (m,n) et renvoie une liste d\'entr\u00E9es :\r\n      { \'m\': int, \'n\': int, \'type\': \'utile\'|\'image\'|\'spurious\'|\'fuite\', \'RF_min\': float, \'RF_max\': float }\r\n    Explications de traitement dans les commentaires du code.\r\n    \"\"\"\r\n    m_max = int(params[\"m_max\"])\r\n    n_max = int(params[\"n_max\"])\r\n    OL = float(params[\"OL_fixe_MHz\"])\r\n    FI_min, FI_max = float(params[\"FI_min_MHz\"]), float(params[\"FI_max_MHz\"])\r\n    RF_min, RF_max = float(params[\"RF_min_MHz\"]), float(params[\"RF_max_MHz\"])\r\n    mode = params.get(\"from\", \"supradyne\").lower().strip()\r\n\r\n    resultats: List[dict] = []\r\n\r\n    for m in range(-m_max, m_max + 1):\r\n        for n in range(-n_max, n_max + 1):\r\n            # ignore le cas trivial (0,0)\r\n            if m == 0 and n == 0:\r\n                continue\r\n\r\n            try:\r\n                # CAS m == 0 => le produit ne d\u00E9pend que de n*OL (fuite possible)\r\n                if m == 0:\r\n                    FI = abs(n * OL)\r\n                    if not (FI_min <= FI <= FI_max):\r\n                        continue\r\n                    lo_c, hi_c = RF_min, RF_max\r\n\r\n                # CAS n == 0 => FI = m * RF  => RF = FI \/ m\r\n                elif n == 0:\r\n                    lo = FI_min \/ abs(m)\r\n                    hi = FI_max \/ abs(m)\r\n                    lo_c = max(lo, RF_min)\r\n                    hi_c = min(hi, RF_max)\r\n                    if lo_c > hi_c:\r\n                        continue\r\n\r\n                # CAS g\u00E9n\u00E9ral : r\u00E9soudre m*RF + n*OL \u2208 [FI_min, FI_max]\r\n                else:\r\n                    rf1 = (FI_min - n * OL) \/ m\r\n                    rf2 = (FI_max - n * OL) \/ m\r\n                    lo, hi = sorted((rf1, rf2))\r\n                    lo_c = max(lo, RF_min)\r\n                    hi_c = min(hi, RF_max)\r\n                    if lo_c > hi_c:\r\n                        continue\r\n\r\n            except ZeroDivisionError:\r\n                # s\u00E9curit\u00E9 (normalement non atteint car m == 0 g\u00E9r\u00E9)\r\n                continue\r\n\r\n            # \u00E9tiquetage\r\n            if m == 0 or n == 0:\r\n                label = \"fuite\"\r\n            elif (mode == \"supradyne\" and (m, n) == (-1, 1)) \\\r\n              or (mode == \"infradyne\" and (m, n) == (1, -1)):\r\n                label = \"utile\"\r\n            elif (mode == \"supradyne\" and (m, n) == (1, -1)) \\\r\n              or (mode == \"infradyne\" and (m, n) == (-1, 1)):\r\n                label = \"image\"\r\n            else:\r\n                label = \"spurious\"\r\n\r\n            resultats.append({\r\n                \"m\":      m,\r\n                \"n\":      n,\r\n                \"type\":   label,\r\n                \"RF_min\": round(lo_c, 2),\r\n                \"RF_max\": round(hi_c, 2),\r\n            })\r\n\r\n    return resultats\r\n\r\n\r\ndef generer_rapport_interference(params: dict) -> List[str]:\r\n    \"\"\"\r\n    V\u00E9rifie deux interf\u00E9rences simples :\r\n      - OL dans la bande FI\r\n      - chevauchement entre bande RF et bande FI\r\n    Retourne une liste de lignes pour insertion dans le fichier rapport.\r\n    \"\"\"\r\n    OL = params[\"OL_fixe_MHz\"]\r\n    RF_min, RF_max = params[\"RF_min_MHz\"], params[\"RF_max_MHz\"]\r\n    FI_min, FI_max = params[\"FI_min_MHz\"], params[\"FI_max_MHz\"]\r\n\r\n    ol_dans_fi = FI_min <= OL <= FI_max\r\n    rf_dans_fi = not (RF_max < FI_min or RF_min > FI_max)\r\n\r\n    lignes = []\r\n    lignes.append(\"=== V\u00E9rification des fuites directes ===\")\r\n    if ol_dans_fi:\r\n        lignes.append(\"\u274C L\'OL est DANS la bande FI \u2192 \u26A0\uFE0F PROBL\u00C8ME\")\r\n    else:\r\n        lignes.append(\"\u2705 L\'OL est HORS de la bande FI\")\r\n    if rf_dans_fi:\r\n        lignes.append(\"\u274C Une partie de la bande RF est DANS la bande FI \u2192 \u26A0\uFE0F PROBL\u00C8ME\")\r\n    else:\r\n        lignes.append(\"\u2705 La bande RF est HORS de la bande FI\")\r\n    lignes.append(\"\")\r\n    return lignes\r\n\r\n\r\n# ---------------------------\r\n# G\u00E9n\u00E9ration du rapport\r\n# ---------------------------\r\n\r\ndef sauvegarder_rapport(resultats: List[dict], fichier: str, params: dict, table_puiss=None, plage_image=None) -> None:\r\n    \"\"\"\r\n    G\u00E9n\u00E8re le rapport texte final \'fichier\'.\r\n    Tri :\r\n      - si table_puiss fournie : tri d\'abord par puissance si disponible (valeur num\u00E9rique plus petite = prioritaire),\r\n        sinon par complexit\u00E9 (|m|+|n|).\r\n      - sinon : tri par complexit\u00E9.\r\n    Format d\'\u00E9criture humain lisible.\r\n    \"\"\"\r\n    sections = {\"utile\": [], \"image\": [], \"spurious\": [], \"fuite\": []}\r\n    for r in resultats:\r\n        sections[r[\"type\"]].append(r)\r\n\r\n    sp = sections[\"spurious\"]\r\n\r\n    if table_puiss is not None:\r\n        # tri en combinant puissance (si dispo) puis complexit\u00E9\r\n        def key_fn(x):\r\n            p = get_puissance(x[\"m\"], x[\"n\"], table_puiss)\r\n            p_key = p if p is not None else float(\'inf\')\r\n            return (p_key, abs(x[\"m\"]) + abs(x[\"n\"]), abs(x[\"m\"]), abs(x[\"n\"]), x[\"RF_min\"])\r\n        sp.sort(key=key_fn)\r\n    else:\r\n        sp.sort(key=lambda x: (abs(x[\"m\"]) + abs(x[\"n\"]), abs(x[\"m\"]), abs(x[\"n\"]), x[\"RF_min\"]))\r\n\r\n    # \u00E9criture s\u00E9curis\u00E9e du fichier (cr\u00E9era\/\u00E9crasera)\r\n    p_out = Path(fichier)\r\n    try:\r\n        with p_out.open(\"w\", encoding=\"utf-8\") as f:\r\n            # Interf\u00E9rences directes OL\/FI et RF\/FI\r\n            interferences = generer_rapport_interference(params)\r\n            for ligne in interferences:\r\n                f.write(ligne + \"\\n\")\r\n\r\n            # Fr\u00E9quences utiles\r\n            f.write(\"=== Fr\u00E9quences utiles ===\\n\")\r\n            f.write(f\"Nombre total : {len(sections[\'utile\'])}\\n\")\r\n            f.write(\"m,   n,  RF_min (MHz),  RF_max (MHz)\\n\")\r\n            for u in sections[\"utile\"]:\r\n                f.write(f\"{u[\'m\']:3d}, {u[\'n\']:3d}, {u[\'RF_min\']:12.1f}, {u[\'RF_max\']:12.1f}\\n\")\r\n            f.write(\"\\n\")\r\n\r\n            # Fr\u00E9quences images\r\n            f.write(\"=== Fr\u00E9quences images ===\\n\")\r\n            f.write(\"Plage de fr\u00E9quence image (MHz) : \\n\")\r\n            if plage_image:\r\n                f.write(f\"{plage_image[0]:8.2f}, {plage_image[1]:8.2f} \\n\\n\")\r\n            else:\r\n                f.write(\"N\/A, N\/A\\n\\n\")\r\n\r\n            # Spurious\r\n            f.write(\"=== Spurious complexes (tri\u00E9s) ===\\n\")\r\n            f.write(f\"Nombre total : {len(sp)}\\n\")\r\n            f.write(\"m,   n,  RF_min (MHz),  RF_max (MHz), Puissance (dBc)\\n\")\r\n            for s in sp:\r\n                pwr = get_puissance(s[\'m\'], s[\'n\'], table_puiss) if table_puiss is not None else None\r\n                pwr_str = f\"{pwr:.1f}\" if pwr is not None else \"\"\r\n                f.write(f\"{s[\'m\']:3d}, {s[\'n\']:3d}, {s[\'RF_min\']:12.1f}, {s[\'RF_max\']:12.1f},       {pwr_str:15}\\n\")\r\n            f.write(\"\\n\")\r\n    except OSError as e:\r\n        raise RuntimeError(f\"Impossible d\'\u00E9crire le fichier de sortie \'{p_out}\': {e}\") from e\r\n\r\n\r\n# ---------------------------\r\n# Entr\u00E9e du script\r\n# ---------------------------\r\n\r\nif __name__ == \"__main__\":\r\n    # D\u00E9termine le dossier du script (m\u00EAme si on ex\u00E9cute depuis un autre cwd).\r\n    # Si __file__ non d\u00E9fini (rare dans REPL), on prend le cwd actuel.\r\n    try:\r\n        script_path = Path(__file__).resolve()\r\n        dossier_script = script_path.parent\r\n    except NameError:\r\n        dossier_script = Path.cwd()\r\n\r\n    # chemins fixes dans le dossier du script\r\n    fichier_yaml = dossier_script \/ \"parametres_spurious.yaml\"\r\n    fichier_txt = dossier_script \/ \"Spurious_results.txt\"\r\n\r\n    # Chargement YAML avec gestion d\'erreur claire\r\n    try:\r\n        params = charger_parametres_yaml(str(fichier_yaml))\r\n    except FileNotFoundError:\r\n        print(f\"[ERREUR] Fichier de param\u00E8tres introuvable : {fichier_yaml}\")\r\n        print(\"Place le fichier \'parametres_spurious.yaml\' dans le m\u00EAme dossier que ce script.\")\r\n        sys.exit(2)\r\n    except Exception as e:\r\n        print(f\"[ERREUR] Impossible de charger le YAML : {e}\")\r\n        sys.exit(3)\r\n\r\n    # Calculs\r\n    try:\r\n        resultats = calculer_plages(params)\r\n        # calcule toujours la plage image (m\u00EAme si hors RF)\r\n        plage_img = calculer_plage_image(params)\r\n    except Exception as e:\r\n        print(f\"[ERREUR] Probl\u00E8me lors des calculs : {e}\")\r\n        sys.exit(4)\r\n\r\n    tab_puiss = params.get(\"puissance_spurious\")\r\n\r\n    # \u00E9criture du rapport (dans le m\u00EAme dossier que le script)\r\n    try:\r\n        sauvegarder_rapport(resultats, str(fichier_txt), params, tab_puiss, plage_img)\r\n        print(f\"[OK] Rapport g\u00E9n\u00E9r\u00E9 : {fichier_txt}\")\r\n    except Exception as e:\r\n        print(f\"[ERREUR] \u00C9criture du rapport \u00E9chou\u00E9e : {e}\")\r\n        sys.exit(5)\r\n",
  "code_yaml":"# === Bande RF (MHz) ===\r\n# Plage de fr\u00E9quences RF que l\'on consid\u00E8re pour la recherche des spurious.\r\n# - RF_min_MHz : borne basse (MHz), float ou int\r\n# - RF_max_MHz : borne haute (MHz), float ou int\r\nRF_min_MHz: 5500      # exemple : 6 GHz\r\nRF_max_MHz: 18000     # exemple : 18 GHz\r\n\r\n# === Oscillateur Local (OL) ===\r\n# OL_fixe_MHz : fr\u00E9quence de l\'oscillateur local (en MHz).\r\n# Remarque : le script utilise OL_fixe_MHz comme valeur unique. Si tu veux balayer\r\n# plusieurs OL, il faudrait modifier le script pour it\u00E9rer sur une liste.\r\nOL_fixe_MHz: 10000    # 10 GHz\r\n\r\n# === Bande FI cible (MHz) ===\r\n# FI_min_MHz \/ FI_max_MHz : la bande FI recherch\u00E9e (en MHz). Toutes les plages\r\n# RF qui g\u00E9n\u00E8rent des produits de m\u00E9lange tombant dans [FI_min_MHz, FI_max_MHz]\r\n# seront conserv\u00E9es (apr\u00E8s intersection avec la bande RF).\r\nFI_min_MHz: 3750\r\nFI_max_MHz: 4250\r\n\r\n# === Coefficients de m\u00E9lange ===\r\n# m_max : valeur maximale (positive) pour |m|\r\n# n_max : valeur maximale (positive) pour |n|\r\n# Le script parcourt m dans [-m_max .. +m_max] et n dans [-n_max .. +n_max].\r\n# Les cas m == 0 et\/ou n == 0 sont trait\u00E9s comme \"fuite\".\r\nm_max: 3\r\nn_max: 5\r\n\r\n# === Type de conversion ===\r\n# \'supradyne\'  -> OL + FI = image (typique OL > RF)\r\n# \'infradyne\'  -> OL - FI = image (typique OL < RF)\r\n# Valeur insensible \u00E0 la casse. Toute autre valeur l\u00E8vera une exception.\r\nfrom: supradyne\r\n\r\n# === Table des puissances des spurious (optionnel) ===\r\n# Structure : liste de lignes (tableau 2D) ; chaque \u00E9l\u00E9ment est soit :\r\n#   - un nombre convertible en float (puissance en dBc)\r\n#   - une cha\u00EEne \'ref\' ou \'na\' (marqueur -> valeur non fournie)\r\n#\r\n# IMPORTANT : convention d\'indexation impl\u00E9ment\u00E9e dans get_puissance(m,n):\r\n#   - ligne index = abs(m) - 1          (donc la premi\u00E8re ligne correspond \u00E0 |m| == 1)\r\n#   - colonne index = abs(n)            (donc la premi\u00E8re colonne correspond \u00E0 n == 0)\r\n#\r\n# En cons\u00E9quence :\r\n#   - nombre de lignes requis >= m_max (puisque ligne index = abs(m)-1 -> m_max -> index m_max-1)\r\n#   - nombre de colonnes requis >= (n_max + 1) (puisque colonne 0 correspond \u00E0 n==0, et colonne n_max correspond \u00E0 |n|==n_max)\r\n#\r\n# Exemple pour m_max=2, n_max=5 :\r\n#   - lignes : au moins 2 (pour |m|=1 et |m|=2)\r\n#   - colonnes : au moins 6 (pour n = 0..5)\r\n#\r\n# Exemple de format (ici fourni tel que dans ton YAML d\'origine) :\r\npuissance_spurious:\r\n   - [-29, -ref, -23, -10, -21, -19]\r\n   - [-85, -61, -73, -65, -71, -69]\r\n   - [-84, -68, -88, -81, -87, -78]\r\n   - [-114, -109, -116, -115, -116, -115]\r\n   - [-119, -123, -128, -126, -127, -128]\r\n",
  "code_path": "files/code/Architecture_verif/Architecture_verif.py",
  "yaml_path": "files/code/Architecture_verif/param.yaml"
},
{
  "filename": "Converting Oscillator Phase Noise to Time Jitter.pdf",
  "title": "Converting Oscillator Phase Noise to Time Jitter",
  "description":"Explication du bruit de phase, Analog Devices",
  "category": "bibliographie",
  "version": "pdf",
  "size_bytes": 124000,
},
{
  "filename": "Investigate Wideband Frequency Converters.pdf",
  "title": "Investigate Wideband Frequency Converters",
  "description":"Récepteur superhétérodyne explication",
  "category": "bibliographie",
  "version": "pdf",
  "size_bytes": 2701000,
},
{
  "filename": "Mixer Basics Primer.pdf",
  "title": "Mixer Basics Primer",
  "description":"Explication des produits de mélange d'un mixer",
  "category": "bibliographie",
  "version": "pdf",
  "size_bytes": 717000,
},
{
  "filename": "Noise Figures of Radio Receivers.pdf",
  "title": "Noise Figures of Radio Receivers",
  "description":"Formule NF en cascade",
  "category": "bibliographie",
  "version": "pdf",
  "size_bytes": 1199000,
},
{
  "filename": "Understand SINAD, ENOB, SNR, THD, THD + N, and SFDR.pdf",
  "title": "Understand SINAD, ENOB, SNR, THD, THD + N, and SFDR",
  "description":"Explication du SFDR",
  "category": "bibliographie",
  "version": "pdf",
  "size_bytes": 93000,
},





//-----------------------------------------------------------------------------
{
  "filename": "code/Architecture_verif.zip",
  "title": "Vérification Architecture",
  "category": "algorithme",
  "version": "final",
  "size_bytes": 15612,
  "description": "Calcul NF, gain, P1dB en cascade.",
  "code_py":"",
  "code_py":"",
  "code_path": "files/code/Architecture_verif/Architecture_verif.py",
  "yaml_path": "files/code/Architecture_verif/param.yaml"
},
];




